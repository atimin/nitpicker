Nitpicker's Workflow
=============================

Nitpicker is created to testers and developer have common workflow and it's supposed that the QA
tests are stored with the source code in CVS repository and new features are developed in the separated
branches:

::

    new_feature  master
        |         |
        *         *
        |         |
        *         |
        |         |
        +---------*


Step 1. Add new test cases
............................

The tester starts their a new branch from *new_feature* for the new test cases and
add a new case in plan *test_new_feature*

.. code-block:: shell

    git checkout -b qa_new_feature
    python -m nitpicker add some_new_case -p test_new_feature

The new case is opened in a text editor and the tester fills in it with some steps
(see :ref:`test_storing`). Then the new case can be committed and pushed to the repository

.. code-block:: shell

    git add qa/test_new_feature/some_new_case.yml
    git commit -m "Add some_new_case.yml"
    git push origin qa_new_feature

If your team practices the code review (I hope it does), then the developer can have a look at the
cases:

::

        qa_new_feature
              |
              * - ("Add some_new_case.yml")
              |
              | new_feature
              |     |
              |     *      master
              |     |         |
              ------*         *
                    |         |
                    *         |
                    |         |
                    +---------*

A test plan can contain test cases as many as you wants. And the tester can repeat command
*python -m nitpicker add* for each test case or copy and rename the file of the first one.


Step 2. Run new test cases
............................

In order to run all the created test cases in the test plan the tester must run command:

.. code-block:: shell

    python -m nitpicker run test_new_feature

Nitpicker runs each test case in the interactive mode and the tester should answer if each step of the
test case is passed or failed. After all the cases have been run, Nitpicker creates a new run report
in directory *qa/test_new_feature/runs/20180820_232000_run.report*. (Note: The new report's name
contains the time when the run was finished)

Then the tester commits the run report and push to the repository:

.. code-block:: shell

    git add qa/test_new_feature/runs/20180820_232000_run.report
    git commit -m "Run test plane 'test_new_feature'"
    git push origin qa_new_feature

Wait a minute.. Why do we need to commit autogenerated data!? Because we have a CI server and
Nitpicker provides some features for it too (see :ref:`ci`).


Step 3. Merging
............................

After step 2 the repository has the following graph:

::

        qa_new_feature
              |
              * - ("Run test plane 'test_new_feature'")
              |
              * - ("Add some_new_case.yml")
              |
              | new_feature
              |     |
              |     *      master
              |     |         |
              ------*         *
                    |         |
                    *         |
                    |         |
                    +---------*


If all the tests are passed and the CI pipeline has no errors the maintainer can merge the branches
in two steps:

.. code-block:: shell

    git fetch origin

    # Merge the QA branch
    git checkout new_feature
    git merge origin/qa_new_feature

    # Merge the feature branch
    git checkout master
    git merge qa_new_feature

    git push origin master